---
layout: post
title: 이왕이면 제너릭 메서드로 만들자
categories: [이펙티브자바]
comments: true 
tags:
- 이펙티브자바
---



클래스와 마찬가지로, 메서드도 제너릭으로 만들 수 있다. `List<E>` 처럼 매개변수화 타입을 받는 정적 유틸리티 메서드는 보통 제너릭이다.

Collections의 binarySeach , sort 등 알고리즘 메서드는 모두 제너릭이다.

**Collections.sort()**

```java
public static <T extends Comparable<? super T>> void sort(List<T> list) {
  list.sort(null);
}
```



## 로우타입으로 만든 제너릭

다음은 두 집합의 합집합을 반환하는데, 문제가 있는 메서드다.

**raw 타입을 사용한 메서드**

```java
public static Set union(Set s1, Set s2) {
  Set result = new HashSet(s1);
  result.addAll(s2);
  return result;
}
```

이 메서드는 정상적으로 컴파일은 되지만 컴파일 경고가 두 개 발생한다.

- **unchecked call to HashSet(Collection<? extends E) as a member of raw type HashSet Set result = new HashSet(s1):**
- **unchecked call to addAll(Collection<? extends E) as a member of raw type Set result.addAll(s);**

첫번 째 경고는 타입 매개변수에 타입을 명시하지 않아 옳바른 타입인지 체크를 할 수 없어서 컴파일러가 경고를 한다.

두번 째 경고는 타입을 알수없는 raw타입인 Set에 원소를 추가하고 있어, 옳바른 타입인지 체크할 수 없어서 컴파일 경고가 난다.

경고를 모두 없애려면 타입을 안전하게 만들어야 한다. 

메서드 선언에서의 세 집합(s1, s1, result) 의 원소타입을 타입 매개변수로 명시하고, 메서드 안에서도 이 타입 매개변수만 사용하도록 수정하면 된다.

**타입 매개변수 목록은 메서드의 제한자와 반환 타입 사이에 온다.**

다음 코드에서 타입 매개변수 목록은 `<E> ` 이고 반환 타입은 `Set<E>` 이다. 

```java
public static <E> Set<E> union(Set<E> s1, Set<E> s2) {
  Set<E> result = new HashSet<>(s1);
  result.addAll(s2);
  return result;
}
```

단순히 제너릭 메서드라면 이 정도면 충분하다

