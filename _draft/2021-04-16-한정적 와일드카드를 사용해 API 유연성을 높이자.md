---
layout: post
title: 한정적 와일드카드를 사용해 API 유연성을 높이자
categories: [이펙티브자바]
comments: true 
tags:
- 이펙티브자바
---



앞에서 이야기 했듯이 매개변수화 타입 (ex: List<String\> 등 )은 불공변이다. 즉 List<String\> 과 List<Object\> 의 하위타입이 아니라는 뜻이다.

List<Object\> 에는 어떤 객체든지 넣을 수 있지만 List<String\> 에는 문자열만 넣을 수 있다. 



## 불공변 방식의 문제점

다음과 같이 Stack 클래스의 public API가 있다.

```java
public class Stack<E> {
  public Stack();
  public void push(E e);
  public E pop();
  public boolean isEmpty();
}
```

여기에 일련의 원소를 스택에 넣는 메서드를 추가한다고 가정해보자.

```java
public void pushAll(Iterable<E> src) {
  for (E e : src)
    push(e)
}
```

**이 메서드는 src의 원소타입이 Stack의 타입과 일치할 때는 정상적으로 작동한다.**

하지만, Stack의 하위타입을 넣고자 할 때는 오류가 발생한다.

다음과 같이 `Stack<Number>` 스택을 하나 선언하고, **Number의 하위 타입인 Integer 값**을 넣어보자.

**`Stack<Number>` 에 Integer 타입 추가**

```java
Stack<Number> numberStack = new Stack<>();
Iterable<Integer> integers = ...;
numberStack.pushAll(integers);
```

위와 같이 코드를 작성하면 **호환되지 않는 타입(incompatible types)** 이라고 컴파일 오류가 나온다.



## 왜 그럴까?

앞서 말한 것처럼 매개변수화 타입인 `List<String>` ,`Collection<Integer>`  등등은 하위타입이 없고 자기자신 그대로만 받기 때문이다. 

아무리 Number의 하위타입이 Integer라고 해도 매개변수화 타입에서 사용되면, 각각 다른 클래스로 보는 것이다.



## 해결 해보기

`Stack<Number>` 의 클래스가 Number의 하위타입인 Integer도 받고 싶으면 매개변수에 한정적 와일드카드 타입을 선언하면 된다.

`Iterable<? extends E> src` 라고 선언하면 된다. 이 코드를 해석하면, **Iterable을 받는데, E타입과 E를 확장한 클래스를 타입으로 받겠다.** 라고 해석하면 된다.

다시 Number의 예제로 돌아가서, `Stack<Number>` 로 Stack을 만들게 되면, `Iterable<? extends Number> src` 이 되기 때문에 정상적으로 컴파일이 된다.

> parameterized type의 제너릭 소거
>
> Parameterized Type의 경우에는 Type erasure에 의하여 컴파일시에 `Raw Type`으로 변경된다.
>
> `List<String>`, `List<Integer>`, `List<List<String>>`의 타입정보는 컴파일 시에 타입 안정성 검증 용도로 사용될 뿐 컴파일이 완료되면 Raw Type인 List로 치환된다.



