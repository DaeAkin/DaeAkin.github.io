---
layout: post
title: raw 타입은 사용하지 말자
categories: [이펙티브자바]
comments: true 
tags:
- 이펙티브자바
---



클래스와 인터페이스 선언에 타입 매개변수가 쓰이면 이를 **제너릭 클래스** 혹은 **제너릭 인터페이스**라고 한다. List 인터페이스로 예를 들자면, List 인터페이스는 원소의 타입을 나타내는 타입 매개변수 E를 받는다. 

`List<String>` 에서는 String이 정규 타입 매개변수 E에 해당하는 실제 타입 매개 변수이다.

## Raw 타입

raw 타입이란, **제너릭 타입에서 타입 매개 변수를 전혀 사용하지 않을 때**를 말한다. 예를 들어 List를 선언할 때 `List` 만 선언해 놓은 경우를 말한다. 

**컬렉션의 Raw 타입**

```java
private final Collection stamps = ...;
```

이 코드를 사용하면 실수로 도장(Stamp) 대신 동전(Coin)을 넣어도 아무 오류 없이 컴파일 되고 실행된다.

```java
//실수로 동전을 넣는다.
stamps.add(new Coin(...)); // "unchecked call" 경고를 내뱉는다.
```

**매개변수화된 컬렉션 타입 - 타입 안전성 확보!**

```java
private final Collection<Stamp> stamps = ...;
```

이렇게 선언하면 컴파일러는 stamps에는 Stamp의 인스턴스만 넣어야 함을 컴파일러가 인지하게 된다. 따라서 아무런 경고 없이 컴파일된다면 의도대로 동작할 것임을 보장해준다.



## 제너릭 소거(Generic erasure)

Raw 타입을 쓰는 걸 언어 차원에서 막아 놓지는 않았지만 절대로 써서는 안 된다. **Raw 타입을 쓰면 제너릭이 안겨주는 안전성과 표현력을 모두 잃게 된다.**

그렇다면 Raw 타입을 왜 없애지 않았을까? 바로 호환성 때문이다. 자바가 제너릭을 받아들이기까지 거의 10년이 걸린 탓에 제너릭 없이 짠 코드가 이미 많아졌다. 그래서 기존 코드를 모두 수용하면서 제너릭을 사용하는 새로운 코드와도 맞물려 돌아가게 해야만 했다.

Raw 타입을 사용하는 메서드에 매개변수화 타입의 인스턴스를 넘겨도 동작해야만 해야했다. 이 마이그레이션 호환성을 위해 Raw 타입을 지원하고 제너릭 구현에는 소거 방식을 사용하기로 했다.



### List vs List<Object\>의 차이

List 같은 Raw 타입은 사용해서는 안되지만, List<Object\> 처럼 임의 객체를 허용하는 매개변수화 타입은 괜찮다. 

이 둘의 차이점은 List는 **제너릭 타입에서 완전히 발을 뺀 것이고** List<Object\>는 모든 타입을 허용한다는 의사를 컴파일러에게 명확히 전달한 것이다.

List 매개변수에는 List<String\>을 전달할 수는 있지만, List<Object\> 매개변수에는 List<String\>을 전달할 수 없다. **즉 타입 안정성을 잃게 된다.**



### 제너릭 소거 더 알아보기

다음과 같은 메서드가 있다.

```java
public static <E> void printArray(E[] array) {
    for (E element : array) {
        System.out.printf("%s ", element);
    }
}
```

이 메서드를 컴파일 하면 다음과 같이 된다.

```java
public static void printArray(Object[] array) {
    for (Object element : array) {
        System.out.printf("%s ", element);
    }
}
```

컴파일 시 E타입이 Object 타입으로 변경이 된다.

이렇게 E 타입만 있는 상황을 unbound 되었다라고 한다.

이번엔 이렇게 해보자.

```java
public static <E extends Comparable<E>> void printArray(E[] array) {
    for (E element : array) {
        System.out.printf("%s ", element);
    }
}
```

이 메서드를 컴파일하면 다음과 같이 된다.

```java
public static void printArray(Comparable[] array) {
    for (Comparable element : array) {
        System.out.printf("%s ", element);
    }
}
```

아까랑은 다르게 E가 부모타입인 Comparable로 되었다.

이렇게 부모 타입으로 변경되는 상황을 bound 되었다라고 한다.



## Raw 타입을 써야 할 때





## 정리