# K8S



## 쿠버네티스는 왜 사용 할까?

오느날의 웹서비스에 대해서, 사용자는 애플리케이션이 24/7 가용하기를 바라고, 개발자는 하루에도 몇 번이고 새로운 버전의 애플리케이션을 배포하기를 바란다. 컨테이너화를 통해 소프트웨어를 패키지하면 **애플리케이션을 다운타임 없이 쉽고 빠르게 릴리스 및 업데이트할 수 있게 되어서 이런 목표를 달성하는데 도움이 된다.** 쿠버네티스는 이렇게 컨테이너화된 애플리케이션을 원하는 곳 어디에든 또 언제든 구동시킬 수 있다는 확신을 갖는데 도움을 주며, 그 애플리케이션이 작동하는데 필요한 자원과 도구를 찾는 것을 도와준다. 쿠버네티스는 구글의 컨테이너 오케스트레이션 부문의 축적된 경험으로 설계되고 커뮤니티로부터 도출된 최고의 아이디어가 결합된 운영 수준의 오픈소스 플랫폼이다.



## 쿠버네티스의 클러스터

**쿠버네티스는 컴퓨터들을 연결하여 단일 형상으로 동작하도록 컴퓨팅 클러스터를 구성하고 높은 가용성을 제공하도록 조율한다.** 사용자는 쿠버네티스의 추상화 개념을 통해 개별 머신에 얽매이지 않고 컨테이너화된 애플리케이션을 클러스터에 배포할 수 있다. 이렇게 새로운 배포 모델을 활용하려면, 애플리케이션을 개별 호스트에 **<u>독립적인 방식</u>**으로 패키징할 필요가 있다. 즉, 컨테이너화가 필요하다. **<u>예전 배치 모델인 설치형 애플리케이션이 특정 머신의 호스트와 밀접하게 통합되는 패키지인 것에 비해, 컨테이너화된 애플리케이션은 유연성(flexible)과 가용성(available)이 훨씬 높다.</u>** **쿠버네티스는 이러한 애플리케이션 컨테이너를 클러스터에 분산시키고 스케줄링하는 일을 더욱 효율적으로 자동화한다.** 쿠버네티스는 오픈소스 플랫폼이며 운영 수준의 안정성(production-ready)을 제공한다.



## 쿠버네티스의 구조

- 마스터 : 클러스터를 조율한다.
- 노드 : 애플리케이션을 구동하는 작업자(worker)이다.![module_01_cluster](https://d33wubrfki0l68.cloudfront.net/99d9808dcbf2880a996ed50d308a186b5900cec9/40b94/docs/tutorials/kubernetes-basics/public/images/module_01_cluster.svg)

Master 하고 Node를 누가할지 어떻게 결정할까?

**<u>마스터는 클러스터 관리를 담당한다.</u>** 애플리케이션을 스케줄링하거나, 애플리케이션의 항상성을 유지하거나, 애플리케이션을 스케일링하고, 새로운 변경사항을 순서대로 반영(rolling out)하는 일과 같은 **클러스터 내 모든 활동을 조율한다.**

> 항상성은 변수들을 조절하여 내부 환경을 안정적이고 상대적으로 일정하게 유지하려는 계의 특성을 말한다.
>

<u>**노드는 쿠버네티스 클러스터 내 워커 머신으로 동작하는 VM 또는 물리적인 컴퓨터다.**</u> 각 노드는 노드를 관리하고 Kubelet이라는 에이전트를 갖는다. 노드는 컨테이너 운영을 담당하는 containerd 또는 도커와 같은 툴도 갖는다. 운영 트래픽을 처리하는 쿠버네티스 클러스터는 **<u>최소 세 대의 노드를 가져야 한다.</u>**

애플리케이션을 쿠버네티스에 배포하기 위해서는, 마스터에 애플리케이션 컨테이너의 구동을 지시하면 된다. 그러면 마스터는 컨테이너를 클러스터의 어느 노드에 구동시킬지 **스케줄한다**. **노드는 마스터가 제공하는 [쿠버네티스 API](https://kubernetes.io/ko/docs/concepts/overview/kubernetes-api/)를 통해서 마스터와 통신한다.** 최종 사용자도 쿠버네티스 API를 사용해서 클러스터와 직접 상호작용(interact)할 수 있다



## 실습

**minikube 버전 확인**

```
$ minikube version 
minikube version: v1.8.1
```



**minikube 실행**

```
$ minikube start
```



### 클러스터 버전

쿠버네티스와 상호작용 하기 위해서는 kubectl를 사용해야 한다. 

**쿠버네티스 설치 확인**

```
$ kubectl version
Client Version: version.Info{Major:"1", Minor:"17", GitVersion:"v1.17.3", GitCommit:"06ad960bfd03b39c8310aaf92d1e7c12ce618213", GitTreeState:"clean", BuildDate:"2020-02-11T18:14:22Z",GoVersion:"go1.13.6", Compiler:"gc", Platform:"linux/amd64"}
Server Version: version.Info{Major:"1", Minor:"17", GitVersion:"v1.17.3", GitCommit:"06ad960bfd03b39c8310aaf92d1e7c12ce618213", GitTreeState:"clean", BuildDate:"2020-02-11T18:07:13Z",GoVersion:"go1.13.6", Compiler:"gc", Platform:"linux/amd64"}
```

명령어를 실행하면, 클라이언트에 설치된 버전이랑 서버에 설치된 버전이 나온다.  서버 버전은 마스터에 설치된 쿠버네티스 버전이며, 클라이언트 버전은 kubectl 버전이다.

### 클러스터 상세정보

**이제 클러스터 상세정보를 출력해보자.**

```
$ kubectl cluster-info
Kubernetes master is running at https://172.17.0.21:8443
KubeDNS is running at https://172.17.0.21:8443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy
```

**클러스터 안에 있는 노드를 보고 싶으면 다음의 명령어를 입력하자**

```
$ kubectl get nodes
NAME       STATUS   ROLES    AGE   VERSION
minikube   Ready    master   12m   v1.17.3
```

이 명령어는 호스트 하고 있는 모든 노드를 출력한다. 