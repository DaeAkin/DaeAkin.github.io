## 설계란 무엇인가?

코드를 어떻게 배치할까 의사결정 이다. 어떤 클래스에 어떤 코드를 넣을 것인지에 관련한

그럼 어떻게 코드를 넣어야 할까?

- **변경의 초점에 맞춰서**
- **의존성에 따라서**



## 의존성이란 무엇인가?

![의존성 사진]({{ site.url }}/images/object-seminar/dependency.png) 

A가 B를 의존한다고 할 때, 다음과 같이 그린다. 여기서, B가 변경될 때, A도 영향을 받는다. 그러므로 의존성은 변경과 관련된 일이다.

그러나 항상 B가 변경된다고 A가 변경되는 걸까? 만약 설계를 잘했으면, B의 내부구현이 바뀐다고 A가 변경이 일어나지 않을 수 있다.

의존성 == 변경에 의해서 영향을 받을 수 있는 가능성

- 클래스 사이 의존성
- 패키지 사이 의존성

클래스 의존성의 종류는 4가지가 있다.

![의존성 종류]({{ site.url }}/images/object-seminar/dependency-kind.png) 

- **연관관계**

  ```java
  class A {
    private B b;
  }
  ```

- **의존관계**

  ```java
  class A {
    public B method(B b) {
      return new B();
    }
  }
  ```

- **상속관계**

  ```java
  class A extends B {
  }
  ```

- **실체화관계**

  ```java
  class A implements B {
  }
  ```



**패키지 의존성**

![의존성 종류]({{ site.url }}/images/object-seminar/package-dp.png) 



# 설계

![도메인 컨셉]({{ site.url }}/images/object-seminar/domain-concept.png) 

이 개념들이 런타임 시 다음과 같은 모양으로 바뀐다.

![도메인 오브젝트]({{ site.url }}/images/object-seminar/domain-object.png) 

주문을 하게 되면 다음의 컨셉을 갖는다.

![도메인 주문 컨셉]({{ site.url }}/images/object-seminar/domain-concept-order.png) 

주문도 런타임 시 이런 모양으로 바뀌게 된다.

![도메인 주문 오브젝트]({{ site.url }}/images/object-seminar/domain-concept.png) 

메뉴와 주문을 붙이면 다음의 모습이 된다.

![도메인 오브젝트 매뉴와 주문]({{ site.url }}/images/object-seminar/domain-object-menu-and-order.png) 

**가게 라는 객체를 중심으로해서 메뉴와 주문이 런타임에 객체들의 관계가 엮인다.**

# 설계 문제점

![메뉴선택 문제점]({{ site.url }}/images/object-seminar/problem-menu-select.png) 

사장님이 메뉴를 1인세트를 등록했다고 가정하자.

그럼 왼쪽의 앱 화면처럼 1인세트가 노출이 된다.

그런데 유저가 1인세트를 선택하고, 장바구니에 담았다. (장바구니정보가 서버에 있지않고, 로컬에 있다고 가정)

**그런데, 그 후에 사장님이 1인 세트의 메뉴의 이름을 0.5인세트로 변경후, 가격도 반값으로 변경을 했다.** 

이렇게 되면 사용자가 담았던 장바구니의 메뉴와, 서버에 있는 메뉴와 불일치가 일어난다.

![주문 불일치]({{ site.url }}/images/object-seminar/order-inconsistency.png) 



# 주문 검증

![주문 검증]({{ site.url }}/images/object-seminar/order-validation.png) 

- 사장님이 등록한 메뉴의 이름과 주문으로 들어온 메뉴의 이름이 같은지 검증
- 옵션그룹의 이름과 주문옵션 그룹의 이름이 같은지 검증을 해야한다.
  - 짜장면 8,000원등록했는데, 짬뽕 8,000원으로 변경이 일어날 경우를 위해서 이름까지 검증해야한다.
- 옵션의 이름과 주문옵션의 이름이 같은지 검증
- 옵션의 가격과 주문옵션의 가격이 같은지 검증
- 장바구니에 담아놓고 한참 뒤에 주문버튼을 눌렀을 경우를 위해 가게가 영업중인지 확인
- 최소주문금액에 만족하는지 검증



# 주문 검증 로직 협력 설계

![주문 검증 로직 협력 설계]({{ site.url }}/images/object-seminar/order-validation-design.png) 

처음 시작은 **주문하기()** 메세지가 주문 객체로 전송이 된다.

그 다음 validation 로직을 모두 태워야 한다.

![클래스 다이어그램]({{ site.url }}/images/object-seminar/order-and-shop-classdiagram.png) 

클래스 다이어그램은 이렇게 나온다.

# 관계를 설정할 때는 방향성이 필요하다

의존성의 관점에서 이 설계를 살펴보자.

개발이 어려운 이유는 위에 그림은 메모리상에서 돌아가는 동적인 구조이다. 객체들이 메세지를 주고받고, 객체가 생성되고, 소멸된다는 것은 시스템상에서 실제로 실행되는 구조이다. 시간이라는게 들어감. 굉장히 변화무쌍하다.

실제로 개발자는 이변화무쌍한 가능성들을 다 정적인 코드로 담아야 한다. 되게 많이 변경이 될 수 있는 모든 가능성들을 관계, 메소드 , 로직 등 정적으로 만들어져야 한다.

정적인 구조를 만들었지만, 코드를 짤때, 정적인 무언가를 찾아야 한다. 그것이 의존성이다.

어떤 객체가 어떤 식으로 의존을 할거야 라는 걸을 실제 코드 상의 정적으로 그려져야 하고, 그걸 관계라고 한다.

런타임에 클래스 인스턴스가 다른 클래스 인스턴스로 어떤식으로 협력이 이루어지는걸 암시하는 것이다.

객체에서는 관계가 필요하다. 의존성이란 것은 어떤애가 어떤애한테 의존해 라는 것이다. 

Source로 부터 Target이 필요하다. 어떤방향으로 흐르는지, DB랑은 다르다 fk가 있으면 방향성이 없음, 아무데나 갈수 있음.

방향성을 결정하는것이 굉장히 중요하다. 관계를 결정하는건, 런타임시 협력이 어떤 방향으로 흐르는지로 결정한다.

어떤 객체가 어떤 객체에게 메세지를 보내는지로도 결정한다.

- 데이터베이스 경우 fk를 잡아만 두면 양방향으로 흐를 수있다.

![관계 방향성]({{ site.url }}/images/object-seminar/relation-direction.png) 

방향성을 결정하는 것이 굉장히 중요하다. 관계를 결정하는 것은 막 하는 것이 아니라, 객체가 어떻게 협력하는지, 런타임 시 객체들이 어떤 방향으로 협력하는지 라는 걸 바탕으로 해서 관계를 잡아줘야 한다.

객체와 객체사이의 어떤식으로 협력하는지, 어떤 메세지를 보내는지를 바탕으로 관계의 방향을 잡아줘야한다. 그것이 바로 의존성의 방향이 된다.

관계의 방향 = 협력의 방향 = 의존성의 방향

![의존성 방향]({{ site.url }}/images/object-seminar/dp-direction.png) 

상속관계와 실체화 관계는 매우 분명하다, 왜냐하면, 상속관계에 경우, extends가 보이면 상속관계이고, implements가 보이면 실체화 관계이기 때문이다.

**연관관계**

연관관계가가 있는데, 내가 협력을 하려고하는데, 어떤 객체 사이의 영구적으로 탐색구조를 잡아줘야할 때, 대부분 데이터 구조를 따라 가지만, 원한다면 끊을 수는 있다.

어떤 객체에서 어떤 객체로 빈번하게 가야하고, 그 경로를 영구적으로 박아놓는게 좋다고 생각이 들면 연관관계로 설정하면 된다.

![연관관계 설정]({{ site.url }}/images/object-seminar/relation-search.png) 

**의존 관계**

의존 관계는 일시적인것, 그 객체가 그객체로 가는 경로가 필요 없다. 여기서 OptionGroupSpecification에서 OrderOptionGroup을 일시적 파라미터로만 받고 끝나버린다. 

![의존관계 설정]({{ site.url }}/images/object-seminar/dp-search.png) 

여기서 중요한거는 연관관계냐 의존관계냐 설정이 아니라, 방향성이 중요하다. 

내가 참조를 할때는 항상 이유가 있어야 한다. 내가 연관관계를 넣는이유, 내가 의존관계를 넣는 이유는 런타임 객체들이 어떻게 협력하느냐에 따라 달라진다.

## 연관관계를 더 알아보자

![연관관계 = 탐색가능성]({{ site.url }}/images/object-seminar/order-search.png) 

연관관계는 탐색가능성을 말한다. 

Order에서 OrderLineItem으로 연관관계를 넣었다는 것은 Order라는 객체를 통해서 내가 원하는 OrderLineItem을 어떤 방식으로 찾아갈 수 있다.





# 잘 설계하기



## 양방향 의존성을 피하라

![의존성 종류]({{ site.url }}/images/object-seminar/bi-direction.png) 

A가 바뀌면 B도 바뀌고 B가 바뀌면 A도 바뀐다. 이건, 한 클래스에 있어야 할 코드들을 억지로 찢어논것이다.



## 다중성이 적은 방향을 선택하라

![의존성 종류]({{ site.url }}/images/object-seminar/manytoone.png) 



## 의존성이 필요 없다면 제거하라

![의존성 제거]({{ site.url }}/images/object-seminar/remove-dp.png) 



## 패키지 사이의 의존성 사이클을 제거하라

![의존성 종류]({{ site.url }}/images/object-seminar/package-cycle-remove.png) 

A pacakge -> B pacakge , B pacakge -> C pacakge, C pacakge -> A pacakge 가 되면 사이클이 생기는데, 이러면, 이 세개의 pacakge들은 한 pacakge 있어야 된다. 같이 바뀌기 때문.

## 설계 개선

저자도, 처음엔 도저히 어떻게 나눌지 생각이 안나서 먼저 절차적으로 짤 때가 많다고한다. 다 짠 다음, 객체들의 의존성을 다이어그램으로 (손) 으로 그려보면 이상한 의존성들이 보인다고 한다.

설계를 개선할 때는 무조건 의존성을 그려보세요. 내 코드에 의존성이 어떤 모양을 갖고 있지 , 사이클은 도나? 패키지를 잘못 나눴나?





![스크린샷 2021-01-10 오후 9.43.03](/Users/donghyeonmin/Library/Application Support/typora-user-images/스크린샷 2021-01-10 오후 9.43.03.png)



![스크린샷 2021-01-10 오후 9.43.03](/Users/donghyeonmin/Library/Application Support/typora-user-images/스크린샷 2021-01-10 오후 9.46.01.png)



이 설계는 사이클이 돌기 때문에, Order를 고치게 되면 Shop도 같이 고치게 된다. 그렇기 때문에, 패키지의 구조가 잘못됐음.

사람들은 추상화란 개념이 인터페이스나, 추상클래스만 있다고 오해하고있음. 추상화란 무엇이냐? 바로 잘 변하지 않는 것![스크린샷 2021-01-10 오후 9.51.00](/Users/donghyeonmin/Library/Application Support/typora-user-images/스크린샷 2021-01-10 오후 9.51.00.png)

여기서 OptionGroup과 Option은 클래스지만. OptionGroupSpecification이랑 OrderOptionGroup 보다는 OptionGroup이 더 추상적.





# 강의

https://www.slideshare.net/baejjae93/ss-151545329?from_action=save

https://www.youtube.com/watch?v=dJ5C4qRqAgA&ab_channel=%EC%9A%B0%EC%95%84%ED%95%9CTech