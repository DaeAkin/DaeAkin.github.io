---
layout: post
title: eqauls를 재정의 하는 방법
categories: [이펙티브자바]
comments: true 
tags:
- 이펙티브자바
---

Object 클래스 안에 equals() 메서드가 있다. 

eqauls() 메서드에 대해서 알아보자.



## eqauls() 메서드를 재정의 하지 않아도 되는 경우

- **각 인스턴스가 본질적으로 고유하다.** 값을 표현하는 게 아니라 동작하는 개체를 표현하는 클래스가 여기 해당한다. Thread가 좋은 예로, Object의 eqauls 메서드는 이러한 클래스에 딱 맞게 구현 되었다. 즉 스레드는 유일하다는 뜻이다.
- **인스턴스의 논리적 동치성(logical equality)을 검사할 일이 없다.** 인스턴스들 끼리 eqauls() 메서드를 사용해서, 논리적으로 같은지 검사할 필요가 없다는 뜻이다. 이럴 경우 Object의 기본 equals 로만으로도 해결된다.
- **상위 클래스에서 재정의한 eqauls가 하위 클래스에도 딱 들어 맞는다.** 대부분의 Set 구현체는 AbstractSet이 구현한 eqauls를 상속받아 쓰고, List 구현체들은 AbstractList로부터, Map 구현체들은 AbstractMap으로부터 상속받아 그대로 쓴다.



> 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다.



## eqauls() 메서드를 재정의 해야 하는 경우

eqauls 메서드를 재정의 해야 하는 경우는, 두 객체가 물리적으로 같은지?(즉 같은 메모리주소를 참조하고 있는지) 가 아니라, 논리적 동치성을 확인해야 하는데, 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 때다.

예를 들어 자바를 처음 접했을 때, 다음과 같은 실수를 한번 씩 접해봤을 것이다.

```java
String str1 = new String("abc");
String str2 = new String("abc");

System.out.println(str1 == str2) // false
```

변수 str1과 str2은 논리적으로는 서로 같은 String을 담고 있지만, == 비교를 하게 되면 메모리 주소값을 비교하기 때문에 false가 나오게 된다.

이럴 때 논리적 동치성 비교를 해야 하는데, 이럴 때 사용하는 것이 eqauls() 메서드이다.

```java
String str1 = new String("abc");
String str2 = new String("abc");

System.out.println(str1.equals(str2)) // true
```

또다른 예로, equals()가 논리적 동치성을 확인하도록 재정의해두면,Map의 키와 Set의 원소를 사용할 수 있게 된다. 

만약 값 클래스라 해도, 값이 같은 인스턴스가 둘 이상 만들어지지 않음을 보장하면 equals()를 재정의 하지 않아도 된다. Enum도 여기에 해당 된다.

같은 값 클래스라면, 내부적으로 동일한 객체를 반환 해주니, 논리적 동치성(equals)이 즉 객체 식별성(==)과 똑같은 의미가 된다.

그렇다면, 재정의는 어떻게 해야 할까?



## eqauls() 재정의 하는 방법

eqauls를 재정의 할 때 다음과 같은 규약을 반드시 따라야 한다. 다음은 Object 명세에 적힌 규약이다.

- **반사성(reflexivity)** : null이 아닌 모든 참조 값 x에 대해, **x.equals(x)는 true**다.
- **대칭성(symmetry)** : null이 아닌 모든 참조 값 x,y에 대해 **x.equals(y)가 true면 y.equals(x)도 true**다.
- **추이성(transitivity)** : null이 아닌 모든 참조 값 x,y,z에 대해, **x.equals(y)가 true이고, y.equals(z)도 true면, x.equals(z)도 true**다.
- **일관성(consistency)** : null이 아닌 모든 참조 값 x,y에 대해 **x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환**한다.
- **null-아님** : null이 아닌 모든 참조 값 x에 대해 x.equals(null)은 false다.



### <u>대칭성</u>을 위반하는 코드

```java
public final class CaseInsensitiveString {
  private final String s;
  
  public CaseInsensitiveString(String s) {
    this.s = Objects.requireNonNull(s);
  }
  
  //대칭성 위배
  @Override
  public boolean equals(Object o) {
    if(o instanceof CaseInsensitiveString)
      return s.equalsIgnoreCase(
    ((CaseInsensitiveString) o).s);
    
    if(o instanceof String) // 한 방향으로만 작동한다.
      return s.equalsIgnoreCase((String)o);
    return false;
  }
}
```

위에 있는 CaseInsensitiveString 클래스는 **대소문자를 구별하지 않는** 문자열을 담는 클래스이다.

재정의한 equals() 메서드를 String 하고 비교를 해보자.

```java
CaseInsensitiveString cis = new CaseInsensitiveString("Polish");
String s = "polish"; 

cis.equals(s); // true
s.equals(cis); // false
```

cis.eqauls(s)는 true로 반환하며, s.eqauls(cis)는 false를 반환하므로, 대칭성을 위반하게 된다.

**다음의 contains() 함수는 무엇을 반환할까?**

```java
CaseInsensitiveString cis = new CaseInsensitiveString("Polish");
String s = "polish"; 

List<CaseInsensitiveString> list = new ArrayList<>();
list.add(cis);

list.contains(s);?
```

contains() 함수는 내부적으로 equals()를 사용하기 때문에 false가 나오게 된다.

이 문제를 해결하려면 CaseInsensitiveString의 equals를 String과 연동하겠다는 꿈을 버려야 한다.

**equals() 를 잘 구현한 모습**

```java
@Override
public boolean equals(Object o) {
	return o instanceof CaseInSensitiveString &&
    ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);
}
```



### <u>추이성</u>을 위반하는 코드

다음은 2차원에서 점을 표현하는 클래스다.

**Point.class**

```java
public class Point {
    protected final int x;
    protected final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public boolean equals(Object o) {
        if (!(o instanceof Point))
            return false;
        Point p = (Point) o;
        return p.x == x && p.y == y;
    }
}
```

그런데 여기서 Point를 상속해서 새로운 클래스인 ColorPoint를 만들어 보자.

**ColorPoint.class**

```java
public class ColorPoint extends Point {
    private final Color color;

    public ColorPoint(int x, int y, Color color) {
        super(x, y);
        this.color = color;
    }
}
```

그럼 ColorPoint 클래스의 equlas() 메서드는 어떻게 해야 할까? 기존에 Point에서 사용하던 eqauls() 메서드를 사용하게 되면 Color 객체는 상관없이 비교를 수행 한다.

그럼 Color 객체도 비교 대상에 포함되도록 eauls() 메서드를 구현 해 보자

```java
    @Override
    public boolean equals(Object o) {
        if(!(o instanceof ColorPoint))
            return false;
        return super.equals(o) && ((ColorPoint)o).color == color;
    }
```

이렇게 작성하면 **대칭성**을 위반한다.

```java
Point p = new Point(1,2);
ColorPoint cp = new ColorPoint(1,2,Color.RED);

p.eqauls(cp); // true
cp.eqauls(p); // false
```

그럼 Point 객체가 들어오면 내부 color를 비교하지 말고, x 와 y 만 비교해보자.

```java
    @Override
    public boolean equals(Object o) {
        if(!(o instanceof Point))
            return false;
        //o 가 일반 Point면 색상을 무시하고 비교함.
        if(!(o instanceof ColorPoint))
            return o.equals(this);
        // o 가 ColorPoint면 색상까지 비교한다.
        return super.equals(o) && ((ColorPoint)o).color == color;
    }
```

그러나 이 코드는 **추이성**을 위반 한다.

```java
ColorPoint p1 = new ColorPoint(1,2,Color.RED);
Point p2 = new Point(1,2);
ColorPoint p3 = new ColorPoint(1,2,Color.BLUE);

p1.eqauls(p2); // true
p2.eqauls(p3); // true
p1.eqauls(p3); // false 
```

그럼 도대체 어떻게 구현 해아 할까?

## eqauls() 제대로 구현 하기

eqauls() 메서드를 제대로 구현하려면 상속 대신 컴포지션 패턴을 이용하는 방법이 있다.

```java
public class ColorPoint {
    private final Point point;
    private final Color color;

    public ColorPoint(Point point, Color color) {
        this.point = point;
        this.color = Objects.requireNonNull(color);
    }

    public Point asPoint() {
        return point;
    }

    @Override
    public boolean equals(Object o) {
        if(!(o instanceof ColorPoint))
            return false;
        ColorPoint cp = (ColorPoint) o;
        return cp.point.equals(point) && cp.color.equals(color);
    }
}
```

