---
layout: post
title: 상속을 고려해 설계하고 문서화 하자. 그러지 않았다면 상속을 금지하자
categories: [이펙티브자바]
comments: true 
tags:
- 이펙티브자바
---



## 상속을 고려한 설계와 문서화

상속을 고려한 설계와 문서화란 메서드를 재정의하면 어떤 일이 일어나는지를 정확히 정리하여 문서로 남겨야 한다는 말이다. **상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.**

예를 들어 <u>HashSet의 클래스</u>를 상속한다고 가정하자. HashSet의 addAll()은 자기의 메서드인 add() 메서드를 이용한다.

![]({{site.url}}/images/item19/hash.png)

이렇게 클래스의 API로 공개된 메서드에서 클래스 자신의 또다른 메서드를 호출할 수도 있다. 그런데 마침 호출되는 메서드가 재정의 가능 메서드라면 그 사실을 호출하는 메서드의 API 설명에 적시해야 한다. 

- 어떤 순서로 호출하는지?
- 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지?

## 문서화를 도와주는 @implSpec

API 문서의 메서드 설명 끝에서 종종 "Implementation Requirements"로 시작하는 절을 볼 수 있는데, 그 메서드의 내부 동작 방식을 설명하는 곳이다. 이 절은 메서드 주석에 @implSpec 태그를 붙여주면 자바독 도구가 생성 해준다.

다음은 AbstactCollection에 있는 remove 함수의 예이다.

![]({{site.url}}/images/item19/AbstactCollection.png)

명세서를 보면 내부적으로 iterator의 remove 메서드를 사용하고 있으며, iterator.remove()를 구현하지 않을 경우 UnsupportedOperationException이 발생한다고 나와 있다.

하지만 이런 식의 문서는 **"좋은 API문서란 '어떻게'가 아닌 '무엇을'을 하는지를 설명해야 한다"** 라는 말과 대치된다. 어쩔 수 없이 상속이 캡슐화를 해치기 때문에 일어나는 안타까운 현실이다. 클래스를 안전하게 상속할 수 있도록 하려면 내부 구현 방식을 설명해야 한다.

@implSepc은 자바 8부터 처음 도입되어 자바 9부터 본격적으로 사용되기 시작했다. 이 어노테이션이 무조건 사용해야되도록 기본값으로 활성화 되어있어야한다고 생각하지만, 아직까지도 선택사항으로 남아있다. 이 태그를 활성화하려면 (사용법은 추후에 작성)



## proected hook 메서드

또 다른 예로 하위 클래스의 성능향상을 위해 클래스의 내부 동작 과정에 끼어 들 수 있는 훅(hook) 메서드를 만들어 proected 메서드로 제공해야 할수 도 있다. 아니면 protected 필드로 공개해야 할 수도 있다.

java.util.AbstarctList의 removeRange를 살펴보자.

