I"H<h2 id="중첩-클래스">중첩 클래스</h2>

<p>중첩 클래스란 다른 클래스 안에 정의된 클래스를 말한다. 중첩 클래스는 자신을 감싼 바깥 클래스에서만 쓰여야 하며, 그 외의 쓰임새가 있다면 톱레벨 클래스로 만들어야 한다.</p>

<h3 id="중첩-클래스의-종류">중첩 클래스의 종류</h3>

<ul>
  <li><strong>정적 멤버 클래스</strong> -&gt; 애만 nested 클래스다.</li>
  <li><strong>(비정적) 멤버 클래스</strong></li>
  <li><strong>익명 클래스</strong></li>
  <li><strong>지역 클래스</strong></li>
</ul>

<h4 id="정적-멤버-클래스">정적 멤버 클래스</h4>

<p>정적 멤버 클래스는 다른 클래스 안에 선언되고, 바깥 클래스의 private 멤버에도 접근할 수 있다는 점만 제외하고는 일반 클래스와 똑같다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OuterClass</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>

  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">InnerClass</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
      <span class="nc">OuterClass</span> <span class="n">outerClass</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">OuterClass</span><span class="o">();</span>
      <span class="c1">//바깥 클래스에 private 멤버에 접근하는 중</span>
      <span class="n">outerClass</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>정적 멤버 클래스는 다른 정적 멤버와 똑같은 규칙을 적용받는다.(위에 예제에서는 OuterClass의 x 변수가 되겠다.)  private으로 선언하면 바깥 클래스에서만 접근할 수 있고, 다른 클래스에서는 절대 접근할 수 없다.</p>

<h4 id="비정적-멤버-클래스">비정적 멤버 클래스</h4>

<p>비정적 멤버 클래스의 인스턴스와 바깥 인스턴스의 사이의 관계는 멤버 클래스가 인스턴스화될 때 확립되며, 더 이상 변경할 수 없다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestClass</span> <span class="o">{</span>

    <span class="kt">void</span> <span class="nf">x</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
    
     <span class="kd">class</span> <span class="nc">NestedClass</span> <span class="o">{</span>
        
        <span class="kt">void</span> <span class="nf">x</span><span class="o">()</span> <span class="o">{</span>
            <span class="nc">TestClass</span><span class="o">.</span><span class="na">this</span><span class="o">.</span><span class="na">x</span><span class="o">();</span>
        <span class="o">}</span>
        
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이렇게 되면 비정적 멤버 클래스의 인스턴스는 바깥 클래스인 TestClass와 암묵적으로 연결되어, 비정적 멤버 클래스의 인스턴스 메서드에서 정규화된 this를 사용해 바깥 인스턴스의 메서드를 호출하거나 바깥 인스턴스의 참조를 가져올 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>

     <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
         <span class="c1">//관계가 확립되었음.</span>
         <span class="k">new</span> <span class="nf">TestClass</span><span class="o">().</span><span class="na">new</span> <span class="nc">NestedClass</span><span class="o">();</span>
     <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>비정적 멤버클래스의 인스턴스와 바깥 인스턴스 사이의 관계는 위와 같이 비정적 멤버 클래스가 인스턴스화 될 때 확립되며 더 이상 변경할 수 없다.</p>

<p>비정적 멤버 클래스는 <a href="https://donghyeon.dev/design%20pattern/2020/02/11/%EC%96%B4%EB%8C%91%ED%84%B0-%ED%8C%A8%ED%84%B4/">어댑터</a> 를 정의할 때 자주 쓰인다. 즉 다른 타입의 인스턴스를 리턴할 때를 말한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MySet</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">AbstractSet</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
  
  <span class="nd">@Override</span> <span class="kd">public</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">iterator</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">MyIterator</span><span class="o">();</span>
  <span class="o">}</span>
  <span class="c1">// 어댑터</span>
  <span class="kd">private</span> <span class="kd">class</span> <span class="nc">MyIterator</span> <span class="kd">implements</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
    
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이렇게 사용하면 바깥 인스턴스로의 숨은 외부 참조를 갖게 된다. 이 참조를 저장하려면 시간과 공간이 소비된다. 더 심각한 문제는 가비지 컬렉션이 바깥 클래스의 인스턴스를 수거하지 못는 <strong><u>메모리 누수</u></strong>가 생길 수 있다는 점이다.</p>

<p><strong>그러므로 멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙여서 정적 멤버 클래스로 만들자.</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MySet</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">AbstractSet</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
  
  <span class="nd">@Override</span> <span class="kd">public</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">iterator</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">MyIterator</span><span class="o">();</span>
  <span class="o">}</span>
  <span class="c1">// 어댑터</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyIterator</span> <span class="kd">implements</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
    
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>비슷하게, Set과 List 같은 다른 컬렉션 인터페이스 구현들도 자신의 반복자를 구현할 때 비정적 멤버 클래스를 주로 사용한다.</p>

<p><strong>Collection.unmodifiableCollection()</strong> 에서는 정적 멤버 클래스를 이용하고 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Collection</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">unmodifiableCollection</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">UnmodifiableCollection</span><span class="o">&lt;&gt;(</span><span class="n">c</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">UnmodifiableCollection</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">Collection</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;,</span> <span class="nc">Serializable</span> <span class="o">{</span>

    <span class="o">}</span>
</code></pre></div></div>

<p>또한 멤버 클래스 역시 공개 API가 되니, 혹시라도 향후 릴리스에서  static을 붙이면 하위 호환성이 깨진다.</p>

<h4 id="익명-클래스">익명 클래스</h4>

<ul>
  <li>
    <p>선언한 지점에서만 인스턴스를 만들 수 있다.</p>
  </li>
  <li>
    <p>비정적 문맥에서 사용될 때만 바깥 클래스의 인스턴스를 참조할 수 있다.</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestClass</span> <span class="o">{</span>
    <span class="nc">Integer</span> <span class="n">intInstance</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
  
    <span class="kt">void</span> <span class="nf">doX</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">new</span> <span class="nf">SInterface</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doSometing</span><span class="o">()</span> <span class="o">{</span>
                <span class="c1">//바깥 인스턴스 참조</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">intInstance</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">};</span>
    <span class="o">}</span>
<span class="o">}</span>
  
  
<span class="kd">interface</span> <span class="nc">SInterface</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">doSometing</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>    </div>

    <ul>
      <li>
        <p>정적 문맥에서라도 상수 변수 이외에 정적 멤버는 가질수 없다.</p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestClass</span> <span class="o">{</span>
    <span class="c1">// 익명클래스에서 사용 불가</span>
    <span class="nc">Integer</span> <span class="n">intInstance</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
    
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">doX</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">new</span> <span class="nf">SInterface</span><span class="o">()</span> <span class="o">{</span>
            <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="c1">//            static int y = 0; // 컴파일에러</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doSometing</span><span class="o">()</span> <span class="o">{</span>
            <span class="o">}</span>
        <span class="o">};</span>
    <span class="o">}</span>
<span class="o">}</span>
    
<span class="kd">interface</span> <span class="nc">SInterface</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">doSometing</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>상수표현을 위해 초기화된 final 기본 타입과 문자열 필드만 가질 수 있다.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>instanceof 검사나 클래스의 이름이 필요한 작업은 수행할 수 없다.</p>
  </li>
  <li>
    <p>여러 인터페이스를 구현할 수 없고 인터페이스를 구현하는 동시에 다른 클래스를 상속할 수도 없다.</p>
  </li>
  <li>
    <p>익명 클래스를 사용하는 클라이언트는 그 익명 클래스가 상위 타입에서 상속한 멤버 외에는 호출할 수 없다.</p>
  </li>
  <li>
    <p>익명 클래스는 표현식 중간에 등장하므로 짧지 않으면 가독성이 떨어진다.</p>
  </li>
  <li>
    <p>자바가 람다를 지원하기 전에는 즉석에서 작은 함수 객체나 처리 객체를 만드는 데 익명 클래스를 주로 사용 했다.</p>

    <ul>
      <li>이제는 람다를 많이 사용한다.</li>
    </ul>
  </li>
  <li>
    <p>익명클래스는 정적 팩터리 메서드를 구현할 때 자주 쓰인다.</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">IntListHelper</span> <span class="o">{</span>
      
    <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">intArrayAsList</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">AbstractList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="nc">Integer</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
            <span class="o">}</span>
  
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">};</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="지역-클래스">지역 클래스</h4>

<ul>
  <li>가장 드물게 사용된다.</li>
  <li>지역변수를 선언할 수 있는 곳이면 어디서든 선언 가능하고, 유효 범위도 지역변수와 같다.</li>
  <li>익명클래스처럼 비정적 문맥에서 사용될 때만 바깥 인스턴스를 참조할 수 있다.</li>
  <li>정적 멤버는 가질 수 없으며 가독성을 위해 짧게 작성해야 한다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestClass</span> <span class="o">{</span>

    <span class="kt">void</span> <span class="nf">x</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">class</span> <span class="nc">LocalClass</span> <span class="o">{</span>
            <span class="kt">void</span> <span class="nf">doPrint</span><span class="o">()</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"LocalClass"</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="정리">정리</h2>

<ul>
  <li>메서드 밖에서도 사용해야 하거나 메서드 안에 정의하기에 너무 길다면 -&gt; <strong>멤버 클래스</strong>
    <ul>
      <li>멤버 클래스의 인스턴스가 바깥 인스턴스를 참조하면 -&gt; <strong>비정적</strong></li>
      <li>멤버 클래스의 인스턴스가 바깥 인스턴스를 참조안하면 -&gt; <strong>정적</strong></li>
    </ul>
  </li>
  <li>중첩 클래스가 한 메서드 안에서만 쓰이면서 그 인스턴스를 생성하는 지점이 단 한곳이고 해당 타입으로 쓰기에 적잡한 클래스나 인터페이스가 있다면 -&gt; <strong>익명 클래스</strong>
    <ul>
      <li>그렇지 않다면? -&gt; <strong>지역 클래스</strong></li>
    </ul>
  </li>
</ul>

<h2 id="참고할-만한-자료">참고할 만한 자료</h2>

<p>https://stackoverflow.com/questions/1953530/why-does-java-prohibit-static-fields-in-inner-classes/1954119#1954119%EB%A5%BC</p>
:ET